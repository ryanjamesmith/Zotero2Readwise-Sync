name: Zotero to Readwise Automation

on:
  workflow_dispatch:
  schedule:
    - cron: "0 11 * * *"  # 04:00 every night in America/Vancouver (11:00 UTC)

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install zotero2readwise
        run: |
          python -m pip install --upgrade pip
          pip install zotero2readwise

            - name: Sync Zotero -> Readwise (force @citationkey titles; resolve parents + title fallback; tolerant POST)
        env:
          READWISE_TOKEN: ${{ secrets.READWISE_TOKEN }}
          ZOTERO_KEY: ${{ secrets.ZOTERO_KEY }}
          ZOTERO_ID: ${{ secrets.ZOTERO_ID }}
        run: |
          python - <<'PY'
          import os, re, time, requests
          from zotero2readwise.zt2rw import Zotero2Readwise

          # ---------- init ----------
          z = Zotero2Readwise(
              readwise_token=os.environ["READWISE_TOKEN"],
              zotero_key=os.environ["ZOTERO_KEY"],
              zotero_library_id=os.environ["ZOTERO_ID"],
              zotero_library_type="user",
              include_annotations=True,
              include_notes=True,
          )

          # ---------- collect items ----------
          raw = z.get_all_zotero_items()
          annot_attach_keys, note_parent_keys = set(), set()
          for it in raw:
              d = it.get("data", {})
              t = d.get("itemType")
              if t == "annotation" and d.get("parentItem"):
                  annot_attach_keys.add(d["parentItem"])
              elif t == "note" and d.get("parentItem"):
                  note_parent_keys.add(d["parentItem"])

          def fetch_items(keys):
              keys = list(keys)
              for i in range(0, len(keys), 50):
                  batch = keys[i:i+50]
                  for itm in z.zotero_client.items(itemKey=",".join(batch)):
                      yield itm

          # attachment -> top-level parent
          attach_to_top = {}
          if annot_attach_keys:
              for att in fetch_items(annot_attach_keys):
                  ad = att.get("data", {})
                  if ad.get("itemType") == "attachment" and ad.get("parentItem"):
                      attach_to_top[ad["key"]] = ad["parentItem"]

          # top-level set
          top_level_keys = set(note_parent_keys) | set(attach_to_top.values())

          # top-level key -> citation key
          rx = re.compile(r"(?im)^citation\s*key\s*[:=]\s*([A-Za-z0-9._:+\-]+)")
          top_to_ck, top_to_title = {}, {}
          if top_level_keys:
              for top in fetch_items(top_level_keys):
                  td = top.get("data", {})
                  top_key = td.get("key")
                  top_title = (td.get("title") or "").strip()
                  top_to_title[top_key] = top_title
                  ck = td.get("citationKey")
                  if not ck:
                      extra = td.get("extra") or ""
                      m = rx.search(extra)
                      if m:
                          ck = m.group(1).strip()
                  if ck:
                      top_to_ck[top_key] = ck

          print(f"Resolved {len(annot_attach_keys)} attachments to {len(top_level_keys)} top-level items")
          print(f"Collected {len(top_to_ck)} citation keys from top-level items")

          # title fallback map
          def norm_title(s: str) -> str:
              return " ".join((s or "").strip().lower().split())
          title_to_ck = {}
          for k, ck in top_to_ck.items():
              t = norm_title(top_to_title.get(k, ""))
              if t and t not in title_to_ck:
                  title_to_ck[t] = ck

          # ---------- POST to Readwise without resp.json() ----------
          RW_URL = "https://readwise.io/api/v2/highlights/"
          RW_HEADERS = {"Authorization": f"Token {os.environ['READWISE_TOKEN']}"}

          def post_highlights_safely(highlights, batch_size=100):
              # chunk & tolerant HTTP handling
              for i in range(0, len(highlights), batch_size):
                  chunk = highlights[i:i+batch_size]
                  for attempt in range(4):
                      resp = requests.post(RW_URL, json={"highlights": chunk},
                                           headers=RW_HEADERS, timeout=60)
                      if resp.status_code in (200, 201, 202, 204):
                          # success (even if body is empty)
                          break
                      if resp.status_code == 429:
                          # brief backoff
                          wait = 2 * (attempt + 1)
                          print(f"Readwise 429, retrying in {wait}s…")
                          time.sleep(wait)
                          continue
                      # other errors: log body and raise
                      print(f"Readwise error {resp.status_code}: {resp.text[:400]}")
                      resp.raise_for_status()

          # rewrite titles before sending, then call our safe poster
          orig_create = z.readwise.create_highlights
          LINK_FIELDS = ("source_url", "highlight_url", "location_url", "url")

          def extract_item_key_from_link(link: str):
              if not link or "zotero://select/items/" not in link:
                  return None
              tail = link.rsplit("/", 1)[-1]
              return tail.split("_")[-1]

          def safe_create(highlights):
              changed_link = 0
              changed_title = 0
              for h in highlights:
                  # link-based mapping
                  key = None
                  for fld in LINK_FIELDS:
                      link = h.get(fld) or ""
                      key = extract_item_key_from_link(link)
                      if key:
                          break
                  if key:
                      top = attach_to_top.get(key, key)
                      ck = top_to_ck.get(top)
                      if ck:
                          h["title"] = f"@{ck}"
                          changed_link += 1
                          continue
                  # title-based fallback
                  tnorm = norm_title(h.get("title", ""))
                  ck = title_to_ck.get(tnorm)
                  if ck:
                      h["title"] = f"@{ck}"
                      changed_title += 1

              print(f"Rewrote {changed_link} via links, {changed_title} via title fallback")
              # Use our tolerant POST instead of library's resp.json()-based method
              post_highlights_safely(highlights, batch_size=100)
              return True

          z.readwise.create_highlights = safe_create

          print("Starting sync…")
          z.run()
          print("✅ Done.")
          PY
